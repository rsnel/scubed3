Copyright
~~~~~~~~~

GPL v3 or (at your option) any later version
This program includes the Mersenne Twister implementation of Geoff Kuenning,
see mtwist.*, the license of those files is LGPL v2 or (at your option) any
later version.


Terminoloy
~~~~~~~~~~

base device: this file/device/database holds all macroblocks, our worst case
threat-model assumes an adversary can make snapshots of it at will

scubed3 partition: a block device whose contents are managed by a scubed3
deamon, writing to a scubed3 partition causes changes to the macroblocks in the base device

macroblocks: the smallest bit of information to someone who doesn't have the
cryptographic key corresponding to it, a macroblock will either change randomly
(each bit changes with a probability of .5) or not at all

mesoblock: in a macroblock a series of mesoblocks are stored, along with
information on where the mesoblock belongs on the scubed3 partition.

indexblock: the first mesoblock in each macroblock contains information
about the other mesoblocks in said macroblock


Threat model
~~~~~~~~~~~~

The adversary has full knowledge about the macroblocks (including history) and
may even have write access to them. This adversary may have keys to some
scubed3 partitions. The goal is to be able to plausibly deny the existance of
partitions to which the adversary has no keys.  Only paranoia level 3 protects
completely against this. We assume the adversary cannot detect read access.


Paranoia levels
~~~~~~~~~~~~~~~

When a new macroblock needs to be selected:

Level 0: not paranoid

it is selected from all allocated blocks based on it's emptyness, the most
empty block gets selected.

Level 1: moderately paranoid

it is randomly selected from all allocated blocks. This hurts write
performance.

Level 2: just paranoid

a random block of the device is selected. If it happens to be allocated to the
current device, it is used. If it happens to be allocated to another device, it
is updated with a new seqno (therefore every bit will change with a probalility
of .5). If the block is unallocated, it will be added to the device, another
block will be deleted. (this level of paranoia is required for flash media,
this kind of media keeps an internal record about the order in whichs blocks
are written to it) It is only safe if all scubed3 devices are known to and
(if active) managed by the scubed3 deamon managing the current device.

[implemented as: select device (weighted by size), and write a random block]

Level 3: extremely paranoid

while active, the daemon writes blocks to random locations at regular intervals
to hide any real activity, this severely hurts performance. Considerations
of level 2 apply. It will wear out your flash very efficiently.


How to start
~~~~~~~~~~~~

You need to provide a set of macroblocks to scubed3, to which it has read/write
access. Normally this is either a file or a block device, but it may be
anything. (you would, however, need to write a custom blockio_init_* function
and provide read, write and close methods to it)


Control protocol
~~~~~~~~~~~~~~~~

/MOUNTPOINT/.control is a file to which commands can be written, and
scubed3's response can be read. A command is a line of text terminated
with a linefeed '\n'.

A response starts with "OK\n", or "ERR\n". One or more lines follow.
The last line must be ".\n". This terminates the message.

Commands:

- status

shows the status

- open NAME MODE KEY

opens a scubed partition

* NAME is the name, like root or swap, whatever, the name has no real meaning,
you can open any partition under any name

* MODE is the ciphermode, eg CBC_LARGE(AES), ABL4(SERPENT256).

* KEY is the cipher key bas16 encoded (hex).

- resize NAME MACROBLOCKS

resizes a scubed partition

* NAME ....

* MACROBLOCKS, the amount of macroblocks owned by the partition


Example calculation if indexblock size
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose the device consists of 10 macroblocks. To not to overwrite the current
rivision while writing the new rivision when, in addition, writing random
blocks. A certain amount of wiggleroom has to be taken into account. Calculations
in 'testing/' point to the the following conjecture:

	wasting 60% of space, leads to 40% wasted writes
	wasting 50% of space, leads to 50% wasted writes
	wasting 40% of space, leads to 60% wasted writes
	etc

So there is a tradeoff between the usable size of a device and the amount of
dummy writes (writing empty macroblocks) that are needed. The amount of blocks
that are USED is specified in simultaneous_blocks. To be efficient, some more
space needs to be wasted, this is specified in reserved_blocks.

For this example we assume the following. Macroblock size 4MB (m). Mesoblock
size 16kB (s). So, there are 256 mesoblocks per macroblock. Mesoblock
0 is the indexblock, the other ones are datablocks.

Whatever values are used, the indexblock MUST fit in one mesoblock! Required
size of the indexblock depends on the maximum amount of macroblocks scubed3 can
support (the size of a backing device can change, so scubed3 should be able to
deal with it, up to a maximum size).

The useful size of the device is
	(1<<(macroblock_log - mesoblock_log) - 1)(simultaneous_blocks - reserved_blocks)

Note that the usable size is limited by 2^32*(1<<mesoblock_log), because the device is partitioned
in mesoblocks, and we have 32 bits available to index the mesoblocks.

Layout of macroblock:

0x000000 SHA256_HASH_INDEXBLOCK
0x000020 SHA256_HASH_DATA (hash of ciphertext)
0x000040 SEQNO_HASH     // hash of the list of seqno's that are required for this revision to be complete
0x000060 uint64_t seqno
0x000068 8byte literal "SSS3v0.1"
0x000070 uint32_t simultaneous_blocks
0x000074 uint32_t reserved_blocks
0x000078 uint32_t no_indices
0x00007C uint32_t idx0x01
0x000080 uint32_t idx0x02
......
0x000474 uint32_t idx0xFF
0x000478 bitmap: each bit represents a macroblock of the base device
		 0 this block is not allocated to us
		 1 this block is allocated to us
0x003FFF last 8 bits of bitmap
0x004000 datablock1
0x008000 datablock2
0x00C000 datablock3
........
0x3FC000 datablock255
0x400000 end

There is space to index 0x4000 - 0x0478 = 0x3B88 = 15240 bytes,
which corresponds to a base device size of 15240*8 = 121920 macroblocks,
which correspond to 4MiB * 121902 = 476GiB

Maximum usable size of the device is 2^32*(1<<mesoblock_log) = 64TiB, which is
sufficient in the light of the maximum size of the backing device.


In general the indexblock requires:
- fixed size: 120 bytes
- 4 bytes for every mesoblock in a macroblock
- 1 bit for every macroblock

Random blockselection
~~~~~~~~~~~~~~~~~~~~~

How to randomly select blocks?

Suppose a device has 8 mesoblocks assigned to it. The state of the device is
currenty contained in:
block 0, seqno 13
block 7, seqno 17
block 3, seqno 18
block 1, seqno 20

Randomly selecting a block from these 8 blocks seems impossible, because we do
not want the new block to be 0, 7, 3 or 1 since that that would damage te state
of the device if something goes wrong during the writing of the new block.

The strategy is to plan ahead. We start with an example in a simple setting.
- there are two macroblocks
- the old macroblock may not be overwritten with the new
- selection of each write must be random

Algorithm description:
- ' ' block empty or overwritten
- '?' candidate block for data
- '-' block used for dummy write
- '0' newest block in current real write sequence
- '1' next newest block in current real write sequence
- etc
- 'd' obsolete data

each step in the algorithm consumes the next random number
if there are more candidates than the number of datablocks
that must stay intact, then de oldest candidate becomes
a real datablock

So, what happens in the case of NO_BLOCKS=6 and
SIMULTANEOUS_BLOCKS=3

seqno  | wr | 012345 | 0123456789ABCDEFGHIJKLMNOPQRSTUV
-------|----|------------------------------------------
       |    |        | 41352133004342031201524400044320
    1  |  0 |        | ?       |       |       |
    2  |  0 |        | ??      |       |       |
    3  |  0 |        | ???     |       |       |
    4  |  1 |     0  | 0???    |       |       |
    5  |  2 |  1  0  | 01???   |       |       |
    6  |  3 |  1 20  | 012???  |       |       |
    7  |  4 |  1 203 | 0123??? |       |       |
    8  |  4 |  1 203 | 0123??/?|       |       |
    9  |  5 |  14203 | 01234?/??       |       |
   10  |  5 |  14203 | 01234?/?/?      |       |
   11  |  7 |  54-03 | 0~~345-?/??     |       |
   12  |  9 | -54-03 | 0~~345.--???    |       |
   13  |  9 | -54-03 | 0~~345r--?/??   |       |
   14  | 11 | 654--3 | ~~~345.-.6-???  |       |
   15  | 12 | 6547-3 | ~~~345...6-7??? |       |
   16  | 13 | 654783 | ~~~345...6.78???|       |
   17  | 14 | 659783 | ~~~3~5...6.789???       |
   18  | 15 | A59783 | ~~~3~5...~.789A???      |
   19  | 16 | A59B83 | ~~~3~5...~.~89AB???     |
   20  | 17 | A-9B83 | ~~~3~~...~.~89AB-???    |
   21  |    |        | ~~~ ~        ~AB-C???   |

seqno  | 012345 | 0123456789ABCDEF
-------|--------------------------
       |        | 2031201524400044
    1  |        | ?       |
    2  |        | ??      |
    3  |        | ???     |
    4  |   0    | 0???    |
    5  | 1 0    | 01???   |
    6  | 1 02   | 012???  |
    7  | 1-02   | 012-??? |
    8  | 1-02   | 012-????|

  0123456789ABCDEF
  2031201524400044
  ?      
  ??     
  ???    
  ????   
  ?????  
  ???-???

0123456
xx     
 xx    
  xx   
x x    
   xx  
 x x   
    xx 
  x x  
     xx
   x x 
x  x   
 x  x  
x   x  
  x  x 
 x   x 
x    x 
    x x
   x  x
  x   x
 x    x
x     x

2031201524400044

0123456789A|
.1         |
 .1        |
  .1       |
. 2        |
   .1      |
 . 2       |
    .1     |
  . 2      |
     .1    |
   . 2     |
.  3       |
      .1   |
    . 2    |
 .  3      |
       .1  |
     . 2   |
  .  3     |
        .1 |
      . 2  |
   .  3    |

???-??????

1+2+3+4

         .1|
       . 2 |
    .  3   |
.   4      |

compare 01
compare 12
	compare 02
compare 23
	compare 13
		compare 03
compare 34
	compare 24
		compare 14
			compare 04
compare 45
	compare 35
		compare 25
			compare 15
				compare 05
compare 56
	compare 46
		compare 36
			compare 26
				compare 16
					compare 06

       |    | disk   | 00000000000000001111111111111111
seqno  | wr | 012345 | 0123456789ABCDEF0123456789ABCDEF
-------|----|------------------------------------------
       |    |        | 41352133004342031201524400044320
    1  |  0 |        | ?       |       |       |
    2  |  0 |        | ??      |       |       |
    3  |  0 |        | ???     |       |       |
    4  |  1 |     0  | 0???    |       |       |
    5  |  2 |  0  1  | 10???   |       |       |
    6  |  3 |  1 02  | 210???  |       |       |
    7  |  4 |  2 130 | 3210??? |       |       |
    8  |  4 |  2 130 | 3210??/?|       |       |
    9  |  5 |  30241 | 43210?/??       |       |
   10  |  5 |  30241 | 43210?/?/?      |       |
   11  |  7 |  01-52 | 5~~210-?/??     |       |
   12  |  9 | -01-52 | 5~~210.--???    |       |
   13  |  9 | -01-52 | 5~~210r--?/??   |       |
   14  | 11 | 012--3 | ~~~321.-.0-???  |       |
   15  | 12 | 1230-4 | ~~~432...1-0??? |       |
   16  | 13 | 234105 | ~~~543...2.10???|       |
   17  | 14 | 340216 | ~~~6.4...3.210???       |
   18  | 15 | 051327 | ~~~7.5...~.3210???      |
   19  | 16 | 162038 | ~~~8.6...~.~3210???     |
   20  | 17 | 1-2038 | ~~~8.~...~.~3210-???    |
   21  |    |        | ~~~              0???   |






              | 00000000000000001
seqno         | 0123456789ABCDEF0
--------------|------------------
random numbers| 11001010010110001
step  1       | ?
step  2       | -?
step  3       |  0?
step  4       |  0-?
step  5       |  1 0?
step  6       |    10?
step  7       |     10?
step  8       |      10?
step  9       |       10?
step 10       |        0-?
step 11       |        1 0?
step 12       |          10?
step 13       |           0-?
step 14       |           1 0?
step 15	      |             0-?
step 16       |             0 -?
step 17       |             1  0?

We can assume, without loss of randomness,  that after a non-dummy write, the
next block pointed to by the random number generator, will be the other block.

The parameters of this example are:
NO_BLOCKS=2 SIMULTANEOUS_BLOCKS=1
